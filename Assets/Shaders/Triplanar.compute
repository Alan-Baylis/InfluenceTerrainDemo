// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

Texture2D<float4> FlatTexture;			//Large source chunk texture
Texture2D<float4> SteepTexture;			//Large source chunk texture
Texture2D<float3> HeightMap;			//Small vertex height map
Texture2D<float3> Normals;				//Small block normal map
int Border;								//Normal map border (for proper cross-chunk blending)
float Lower;							//World meters height for 0 in HeightMap
float Upper;							//World meters height for 1 in HeightMap
float SteepAngleFrom;					//From-To angles to blend between Flat and Steep textures
float SteepAngleTo;
//int2 WorldPos;

RWTexture2D<float4> Result;			//Large result chunk texture

SamplerState _LinearClamp;
SamplerState _PointClamp;

#include "Assets\Shaders\Common.cginc"

//Chunk size in meters
#define CHUNK_SIZE_M					16.0

[numthreads(8,8,1)]
void CSMain (uint2 id : SV_DispatchThreadID)
{
	//Based on http://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821

	float2 dim;	
    Result.GetDimensions(dim.x, dim.y);
	float2 uv = float2(id.x/(dim.x - 1), id.y/(dim.y - 1));

	//Get Y world space
	float heightMapSize;
	HeightMap.GetDimensions(heightMapSize, heightMapSize);
	float2 heightUV = scaleUV(uv, 0.5, heightMapSize);
	float3 wTexel = HeightMap.SampleLevel(_LinearClamp, heightUV, 0);			//Set normalized height as y
	wTexel.x = uv.x;
	wTexel.z = uv.y;
	wTexel.y = (lerp(Lower, Upper, wTexel.y) % CHUNK_SIZE_M) / CHUNK_SIZE_M;			//World meters to uv

	//Scale uv because of border
	float normalsSize;
	Normals.GetDimensions(normalsSize, normalsSize);
	float2 normalUV = scaleUV(uv, Border, normalsSize);
	
	//Get blending weights
	float3 wNorm = Normals.SampleLevel(_LinearClamp, normalUV, 0);
	wNorm = wNorm * 2 - 1;							//Restore normal vector from color
	float3 blending = abs( wNorm );
	blending = normalize(max(blending, 0.00001)); 

	//Get blending for slope textures
	float2 slopeAxis = float2(blending.x, blending.z);
	float slopeSum = blending.x + blending.z;
	slopeAxis /= float2(slopeSum, slopeSum);
	float4 xPixel = SteepTexture.SampleLevel(_LinearClamp, wTexel.zy, 0);
	float4 zPixel = SteepTexture.SampleLevel(_LinearClamp, wTexel.xy, 0);
	float4 steepPixel = SoftDepthBlend(xPixel, zPixel, slopeAxis.y);			

	//Blend with flat texture
	float angle = degrees(acos(wNorm.y));			//Get fragment world angle to vertical
	Result[id] = SoftDepthBlend(FlatTexture.SampleLevel(_LinearClamp, uv, 0), steepPixel, Compress(angle, SteepAngleFrom, SteepAngleTo));
}
